
# Инструкция по подключению бэкенда

Этот документ описывает стратегию и шаги для перехода от моковых (статичных) данных к полноценной клиент-серверной архитектуре с бэкендом.

## Общая концепция: API-ориентированный подход

Frontend-приложение (React) будет выступать в роли "клиента", который обменивается данными с бэкендом через API. Бэкенд станет единственным источником правды: он будет хранить данные, выполнять бизнес-логику и обеспечивать безопасность.

---

## 1. Проектирование REST API

Для взаимодействия между клиентом и сервером будет использоваться REST API.

### 1.1. Основные ресурсы

- `/users` — данные пользователей (Магнатов).
- `/projects` — структура Проектов.
- `/transactions` — история операций и создание новых.
- `/leaderboard` — список лидеров.
- `/stats` — общая статистика Метрополиса.
- `/guild` — данные о Гильдии пользователя.
- `/notifications` — уведомления.

### 1.2. Ключевые эндпоинты (Endpoints)

| Метод | Эндпоинт                        | Описание                                               |
|-------|---------------------------------|--------------------------------------------------------|
| `GET`   | `/api/users/me`                 | Получить данные текущего авторизованного пользователя. |
| `PUT`   | `/api/users/me`                 | Обновить профиль текущего пользователя.                |
| `GET`   | `/api/users/:id`                | Найти пользователя по ID (для функции переводов).      |
| `GET`   | `/api/projects/:userId`         | Получить структуру Проекта для пользователя.           |
| `POST`  | `/api/transactions/deposit`     | Создать заявку на покупку Городских Кредитов.          |
| `POST`  | `/api/transactions/withdraw`    | Создать заявку на продажу Городских Кредитов.          |
| `POST`  | `/api/transactions/transfer`    | Выполнить внутренний перевод средств.                  |
| `GET`   | `/api/transactions`             | Получить историю транзакций.                           |
| `POST`  | `/api/ai/generate-content`      | Сгенерировать маркетинговый контент (безопасный вызов Gemini). |
| `GET`   | `/api/stats/metropolis`         | Получить общую статистику Метрополиса.                  |

### 1.3. Перенос бизнес-логики на бэкенд

Вся логика, которая сейчас находится на фронтенде, должна быть перенесена на сервер:
- Расчет баланса пользователя (Городских Кредитов).
- Логика завершения Проектов и начисления арендной платы.
- Проверка возможности перевода (достаточно ли средств с учетом комиссии).
- Валидация всех пользовательских данных.
- Сортировка и фильтрация данных (например, в таблице Гильдии).

---

## 2. Безопасность

### 2.1. Аутентификация через JWT

1.  **Вход**: Пользователь отправляет логин/пароль на эндпоинт `POST /api/auth/login`.
2.  **Получение токена**: В случае успеха бэкенд возвращает `JWT-токен`.
3.  **Хранение**: Фронтенд сохраняет токен (например, в `localStorage` или `HttpOnly cookie`).
4.  **Авторизованные запросы**: При каждом последующем запросе к защищенным эндпоинтам фронтенд должен добавлять токен в заголовок `Authorization: Bearer <token>`.

### 2.2. Безопасное использование Gemini API

Ключ для Gemini API **должен храниться исключительно на бэкенде** и никогда не передаваться на клиент.
- Фронтенд отправляет запрос на эндпоинт `POST /api/ai/generate-content` с текстом промпта.
- Бэкенд принимает этот запрос, добавляет свой секретный API-ключ и делает вызов к Gemini.
- Результат возвращается на фронтенд.

---

## 3. План интеграции во Frontend (React)

### 3.1. Создание API-сервиса

Создать централизованный модуль (например, `src/services/api.ts`) для всех API-запросов. Этот модуль будет использовать `fetch` или `axios` и автоматически добавлять JWT-токен в заголовки.

```typescript
// Примерная структура services/api.ts

const BASE_URL = '/api';

const getAuthHeaders = () => {
  const token = localStorage.getItem('jwt_token');
  return {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`
  };
};

export const fetchCurrentUser = async () => {
  const response = await fetch(`${BASE_URL}/users/me`, { headers: getAuthHeaders() });
  if (!response.ok) throw new Error('Failed to fetch user');
  return response.json();
};

export const createTransfer = async (recipientId, amount, comment) => {
  // ... логика POST-запроса
};

// ... другие функции для каждого эндпоинта
```

### 3.2. Замена моковых данных на API-вызовы

Необходимо последовательно пройти по всем компонентам и заменить использование констант из `constants.ts` на вызовы функций из API-сервиса.

- **App.tsx**: Вместо `useState(MOCK_USER)` использовать `useEffect` для вызова `fetchCurrentUser()` при загрузке приложения.
- **Dashboard.tsx**: Загружать статистику Метрополиса и пользователя через API.
- **BankView.tsx**: Формы покупки, продажи и перевода должны отправлять запросы на бэкенд. После успешного ответа — обновлять историю транзакций, запросив ее снова.
- **ProjectView.tsx**: Загружать корневой узел Проекта. При клике на другого участника — отправлять новый запрос для получения его структуры.

### 3.3. Обработка состояний загрузки и ошибок

Каждый компонент, получающий данные, должен управлять тремя состояниями:
- `loading`: Пока данные загружаются, показывать спиннер или скелетон-загрузчик.
- `data`: Если данные успешно получены, отображать их.
- `error`: Если API вернул ошибку, показывать пользователю понятное сообщение.

**Пример для компонента Dashboard:**
```typescript
// псевдокод
const Dashboard = () => {
  const [stats, setStats] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const loadStats = async () => {
      try {
        setLoading(true);
        const metropolisStats = await api.getMetropolisStats();
        setStats(metropolisStats);
      } catch (err) {
        setError('Не удалось загрузить статистику');
      } finally {
        setLoading(false);
      }
    };
    loadStats();
  }, []);

  if (loading) return <Spinner />;
  if (error) return <ErrorMessage message={error} />;
  
  return (
    // ... разметка с данными из state `stats`
  );
}
```

---

## 4. Real-time обновления (Живая лента)

Для "Живой ленты" (`LiveFeed`) вместо постоянных запросов (polling) следует использовать **WebSockets**.
1.  Бэкенд предоставляет WebSocket-сервер.
2.  Фронтенд устанавливает соединение после авторизации пользователя.
3.  Бэкенд отправляет сообщения о новых событиях (регистрация, вывод и т.д.) всем подключенным клиентам.
4.  Фронтенд, получив сообщение, добавляет новое событие в начало списка, создавая эффект реального времени.
